---
id: 40
title: 40.组合总和 II
date: '2020-03-16'
level: medium
hot: 4
author:
  name: Nate Wang
  picture: '/assets/authors/logo.png'
postShow: true
tags:
  - 回溯
category: algorithm
subCategory: everyDay
---



# [组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/description/)

> 给定一个候选人编号的集合 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的每个数字在每个组合中只能使用 **一次** 。

**注意：**解集不能包含重复的组合。  

**示例 1:**

```
输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
```

**示例 2:**

```
输入: candidates = [2,5,2,1,2], target = 5,
输出:
[
[1,2,2],
[5]
] 
```

**提示:**

- `1 <= candidates.length <= 100`
- `1 <= candidates[i] <= 50`
- `1 <= target <= 30`

------

[Discussion](https://leetcode-cn.com/problems/combination-sum-ii/comments/) | [Solution](https://leetcode-cn.com/problems/combination-sum-ii/solution/)

### 题解 - 回溯 + 剪枝





```js
const combinationSum = (candidates, target) => {

  const ret = [], ans = [], used = [];
  const len = candidates.length;
  let sum = 0;
	
  // 
  candidates.sort((a, b) => a - b);

  const backTracking = (sum, target, i, used) => {
    
    if (sum === target) {
      ret.push([...ans]);
      return;
    }
    for (let j = i; j < len && sum + candidates[j] <= target; j++) {

      if (j > 0 && candidates[j] == candidates[j - 1] && !used[j - 1]) {
        continue;
      }
      ans.push(candidates[j]);
      used[j] = 1;
      backTracking(sum + candidates[j], target, j + 1, used);
      // 回溯操作
      used[j] = 0;
      ans.pop();
    }
  }
  backTracking(sum, target, 0, used);
  return ret;
}
```
